package train

import "fmt"

func Slice() {

	//数组
	/**
		1. 数组是多个相同类型数据的组合，一个数组一旦声明/定义了，其长度是固定的，不能动态变化

	　　	2. 数组创建后，如果没有赋值，则有默认值。字符串：“”; 数值：0; bool数组：false

	　　	3. 数组默认情况下是值传递，若想修改原数组，可以使用引用传递

	　　	4. 长度是数组类型的一部分，传递函数参数时，需要考虑数组的长度，
	*/

	//切片
	/**
		1. 切片是数组的一个引用，在进行传递时，遵守引用传递机制；

	　　	2. 切片的长度是可以变化的，因此切片是一个动态变化数组

	　　	3. 切片定义：var 变量名 [] 类型，如 var a [] int

	　　	4. 从底层看，其实是一个struct结构体，里面存有指针、len和cap

	　　	5. var slice = arr[0:len(arr)]可以简写为var slice = arr[:]

	　　	6. 切片可以继续切片
	*/

	//总结
	/**
	数组是值类型，切片是引用类型，是对底层数组的引用，不存储具体的值
	因此：
		如果复制数组，可以直接通过=赋值进行复制；
		如果复制切片，可以直接使用copy()；

		target:= make([]int, len(source))
		copy(target, source)

	对切片进行元素值修改，会同步改动底层数组对应索引值
	*/

	//append操作底层原理分析
	/**
		1. 切片append操作的本质是对数组扩容

	　　	2. go底层会创建一个新的数组newArr

	　　	3. 将slice原来的元素拷贝到新数组newArr中

	　　	4. slice重新引用到newArr
	*/
}

/*
*
下面这段代码输出什么？
*/
func demo() {
	a := [5]int{1, 2, 3, 4, 5}
	t := a[3:4:4]
	fmt.Println(t[0])
}

/**
知识点：操作符 [i,j]。基于数组（切片）可以使用操作符 [i,j] 创建新的切片，从索引 i，到索引 j 结束，截取已有数组（切片）的任意部分，返回新的切片，新切片的值包含原数组（切片）的 i 索引的值，但是不包含 j 索引的值。i、j 都是可选的，i 如果省略，默认是 0，j 如果省略，默认是原数组（切片）的长度。i、j 都不能超过这个长度值。

假如底层数组的大小为 k，截取之后获得的切片的长度和容量的计算方法：

长度：j-i，容量：k-i

截取操作符还可以有第三个参数，形如 [i,j,k]，第三个参数 k 用来限制新切片的容量，但不能超过原数组（切片）的底层数组大小。截取获得的切片的长度和容量分别是：j-i、k-i。

所以例子中，切片 t 为 [4]，长度和容量都是 1。
*/

/*
*
以下代码输出什么：
*/
func len1() {
	var x *struct {
		s [][32]byte
	}

	println(len(x.s[99])) //32
}

/**
len 函数是一个内置类型，什么意思？就是由编译器实现的。它的参数可以接收多种类型，有泛型的味道。

func len(v Type) int
关于它的说明，标准库文档有说明：

内建函数 len 返回 v 的长度，这取决于具体类型：

数组：v 中元素的数量
数组指针：*v 中元素的数量（v 为 nil 时 panic）
切片、map：v 中元素的数量；若 v 为nil，len(v) 即为零
字符串：v 中字节的数量
通道：通道缓存中队列（未读取）元素的数量；若 v 为 nil，len(v) 即为零
光这个解释，还不够全面，len 函数还有其他一些特殊的点。这要看 Go 语言规范。

在规范中，有一节是关于 len 和 cap 的。有如下几个要点：

返回结果总是 int；
返回结果有可能是常量；
有时对函数参数不求值，即编译期确定返回值；
2、3 点解释下。（规范中有说明）

如果 len 或 cap 的函数参数 v 是字符串常量，则返回值是一个常量。

如果 v 的类型是数组或指向数组的指针，且表达式 v 没有包含 channel 接收或（非常量）函数调用，则返回值也是一个常量。这种情况下，不会对 v 进行求值（即编译期就能确定）。否则返回值不是常量，且会对 v 进行求值（即得运行时确定）。

这一点是这道题的关键。

首先，x.s[99] 的类型是 [32]byte，它是一个数组，且表达式 x.s[99] 没有包含 channel 接收也不是函数调用，因此不会对 x.s[99] 进行求值，不求值自然不会 panic（想不明白？可以想成没有解引用操作）。也就是说，编译器能够在编译阶段分析出 x.s[99] 的类型是 [32]byte，且不需要对 x.s[99] 求值，因此直接返回数组的长度，即 32。

其他类似情况
类似这样不求值的情况还有没有？还真有。比如下面的代码：

var testdata *struct {
  a *[7]int
}
for i, _ := range testdata.a {
  fmt.Println(i)
}
同样不会 panic，原理和上面的类似，在 Go 语言规范有说明。

"range" 子句中右侧的表达式被称为 range 表达式 ，它可以是数组、数组的指针、切片、字符串、map或是允许接收操作 的 channel。range 表达式会在开始此循环前被求值一次，但有一个例外：当存在最多一个迭代变量且 len(x) 是常量时，range 表达式是不被求值的。

所以上面代码中 testdata.a 不会被求值，因为 len(testdata.a) 是常量。

但如果改为这样：

var testdata *struct {
  a *[7]int
}
for i, j := range testdata.a {
  fmt.Println(i, j)
}
就会 panic。
*/

/*
*
下面这段代码能否正常结束？
*/
func range1() {
	v := []int{1, 2, 3}
	for i := range v {
		v = append(v, i)
	}
}

/**
不会出现死循环，能正常结束。

循环次数在循环开始前就已经确定，循环内改变切片的长度，不影响循环次数。

range 表达式是副本参与循环。就是说例子中参与循环的是 v 的副本，而不是真正的 v

https://tonybai.com/2015/09/17/7-things-you-may-not-pay-attation-to-in-go/
*/
