package train

import "fmt"

func Slice() {

	//数组
	/**
		1. 数组是多个相同类型数据的组合，一个数组一旦声明/定义了，其长度是固定的，不能动态变化

	　　	2. 数组创建后，如果没有赋值，则有默认值。字符串：“”; 数值：0; bool数组：false

	　　	3. 数组默认情况下是值传递，若想修改原数组，可以使用引用传递

	　　	4. 长度是数组类型的一部分，传递函数参数时，需要考虑数组的长度，
	*/

	//切片
	/**
		1. 切片是数组的一个引用，在进行传递时，遵守引用传递机制；

	　　	2. 切片的长度是可以变化的，因此切片是一个动态变化数组

	　　	3. 切片定义：var 变量名 [] 类型，如 var a [] int

	　　	4. 从底层看，其实是一个struct结构体，里面存有指针、len和cap

	　　	5. var slice = arr[0:len(arr)]可以简写为var slice = arr[:]

	　　	6. 切片可以继续切片
	*/

	//总结
	/**
	数组是值类型，切片是引用类型，是对底层数组的引用，不存储具体的值
	因此：
		如果复制数组，可以直接通过=赋值进行复制；
		如果复制切片，可以直接使用copy()；

		target:= make([]int, len(source))
		copy(target, source)

	对切片进行元素值修改，会同步改动底层数组对应索引值
	*/

	//append操作底层原理分析
	/**
		1. 切片append操作的本质是对数组扩容

	　　	2. go底层会创建一个新的数组newArr

	　　	3. 将slice原来的元素拷贝到新数组newArr中

	　　	4. slice重新引用到newArr
	*/
}

/*
*
下面这段代码输出什么？
*/
func demo() {
	a := [5]int{1, 2, 3, 4, 5}
	t := a[3:4:4]
	fmt.Println(t[0])
}

/**
知识点：操作符 [i,j]。基于数组（切片）可以使用操作符 [i,j] 创建新的切片，从索引 i，到索引 j 结束，截取已有数组（切片）的任意部分，返回新的切片，新切片的值包含原数组（切片）的 i 索引的值，但是不包含 j 索引的值。i、j 都是可选的，i 如果省略，默认是 0，j 如果省略，默认是原数组（切片）的长度。i、j 都不能超过这个长度值。

假如底层数组的大小为 k，截取之后获得的切片的长度和容量的计算方法：

长度：j-i，容量：k-i

截取操作符还可以有第三个参数，形如 [i,j,k]，第三个参数 k 用来限制新切片的容量，但不能超过原数组（切片）的底层数组大小。截取获得的切片的长度和容量分别是：j-i、k-i。

所以例子中，切片 t 为 [4]，长度和容量都是 1。
*/
